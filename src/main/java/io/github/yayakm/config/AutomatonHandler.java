/*
 * Copyright (c) 2024, Yaya Kamissokho
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.yayakm.config;

import dk.brics.automaton.Automaton;
import dk.brics.automaton.RegExp;
import dk.brics.automaton.State;
import dk.brics.automaton.Transition;
import io.github.yayakm.exception.RegexStringGeneratorException;
import io.github.yayakm.util.Length;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

/**
 * Handles operations related to finite automata for regular expressions.
 * This class allows modifying and querying properties of the automaton based on regex patterns,
 * enforcing global length constraints, and ensuring the generation of valid text strings.
 * <p>
 * It provides methods to set regular expressions, validate length constraints, and
 * retrieve properties such as the number of states and determinism.
 *
 * @author yaya.kamissokho@gmail.com
 */
public class AutomatonHandler {
    private Automaton automaton;
    private int globalMaxLength = Integer.MAX_VALUE;  // Maximum allowable length for any regex
    private int globalMinLength = 1;                  // Minimum allowable length for any regex

    /**
     * Default constructor initializing an AutomatonHandler without a regex pattern.
     */
    public AutomatonHandler() {
    }

    /**
     * Constructs an AutomatonHandler with a specific regular expression.
     *
     * @param regExp the regular expression to convert into an Automaton.
     */
    public AutomatonHandler(String regExp) {
        setRegExp(regExp);
    }

    /**
     * Retrieves properties of the automaton, such as the number of states and its finiteness.
     *
     * @return AutomatonProperties containing details about the automaton's structure.
     * @throws RegexStringGeneratorException if the automaton is not initialized
     */
    public AutomatonProperties getAutomatonProperties() {
        ensureAutomatonInitialized();

        int numberOfStates = automaton.getNumberOfStates();
        boolean isFinite = automaton.isFinite();

        if (isFinite) {
            Length length = getExpectedLength();
            return new AutomatonProperties(numberOfStates, true, length);
        }

        return new AutomatonProperties(numberOfStates, false);
    }

    /**
     * Calculates and returns the expected minimum and maximum lengths of text that the automaton can generate.
     * This method leverages the automaton's state transitions to determine the shortest and longest possible
     * paths that lead to an accepting state, which represent the valid strings generated by the regular expression.
     * <p>
     * The method initializes a map to store the lengths for each state and uses a breadth-first search approach
     * to populate this map. Each accepting state's lengths are then examined to find the overall shortest and longest
     * valid strings the automaton can generate.
     *
     * @return Length containing the minimum and maximum lengths the automaton can produce. If the automaton has no
     * accepting states reachable from the initial state, the minimum length will be set to Integer.MAX_VALUE
     * and the maximum length to zero, indicating that no valid strings can be generated.
     * @throws RegexStringGeneratorException if the automaton has not been initialized prior to calling this method,
     *                                       indicating that the regular expression setup is incomplete.
     */
    public Length getExpectedLength() {
        // Ensure the automaton is properly initialized before proceeding.
        ensureAutomatonInitialized();

        // Get the initial state of the automaton, which is the starting point for length calculations.
        State initialState = automaton.getInitialState();

        // Map to store the minimum and maximum path lengths to each state.
        Map<State, Length> lengthsMap = new HashMap<>();

        // Explore lengths from the initial state to populate the lengths map.
        exploreLengths(initialState, lengthsMap);

        // Initialize variables to find the overall shortest and longest lengths to accepting states.
        int minPossibleLength = Integer.MAX_VALUE;
        int maxPossibleLength = 0;

        // Iterate through all states and their associated lengths.
        for (Map.Entry<State, Length> entry : lengthsMap.entrySet()) {
            if (entry.getKey().isAccept()) { // Only consider accepting states.
                Length length = entry.getValue();
                // Update the minimum and maximum lengths found so far.
                minPossibleLength = Math.min(minPossibleLength, length.getMin());
                maxPossibleLength = Math.max(maxPossibleLength, length.getMax());
            }
        }

        return new Length(minPossibleLength, maxPossibleLength);
    }


    /**
     * Explores all reachable states from a given initial state and calculates their possible lengths
     * in terms of transitions. This method uses a breadth-first search approach to traverse through
     * the automaton starting from the specified initial state. It updates a map with the minimum and
     * maximum lengths possible to reach each state.
     * <p>
     * This breadth-first search ensures that all states are visited in the shortest path first manner,
     * allowing the calculation of the shortest and longest paths to each state in terms of the number
     * of transitions. This is crucial for determining valid string lengths that the automaton can generate
     * based on the given regular expression.
     *
     * @param state      the initial state to start the exploration from. This is typically the initial state
     *                   of the automaton.
     * @param lengthsMap a map to store the lengths calculated for each state. Each state is associated
     *                   with a Length object that stores the minimum and maximum lengths of paths leading
     *                   to that state from the initial state. This map is updated in-place.
     */
    private void exploreLengths(State state, Map<State, Length> lengthsMap) {
        Queue<State> queue = new LinkedList<>();
        queue.add(state);
        // Initialize the starting state's length to 0,0 since no transitions have been made yet.
        lengthsMap.put(state, new Length(0, 0));

        while (!queue.isEmpty()) {
            State current = queue.poll();
            Length currentLength = lengthsMap.get(current);

            // Iterate through all transitions from the current state.
            for (Transition transition : current.getTransitions()) {
                State dest = transition.getDest();
                // Each transition is considered to have a length of 1.
                int transitionLength = 1;

                // Calculate the new minimum and maximum lengths for the destination state.
                int newMin = currentLength.getMin() + transitionLength;
                int newMax = currentLength.getMax() + transitionLength;

                // Retrieve or initialize the Length object for the destination state.
                Length destLength = lengthsMap.get(dest);

                // Update the Length object if this new path is shorter or longer than previously recorded paths.
                if (destLength == null || destLength.update(newMin, newMax)) {
                    queue.add(dest);
                    lengthsMap.putIfAbsent(dest, new Length(newMin, newMax));
                }
            }
        }
    }


    /**
     * Validates the text generation capabilities against global and expected length constraints.
     *
     * @param minLength               the minimum length of the text to generate
     * @param maxLength               the maximum length of the text to generate
     * @param expectedGeneratedLength the expected length range of the generated text
     * @throws RegexStringGeneratorException if the specified lengths do not conform to the allowed ranges
     */
    public void validateTextGenerationCapacity(int minLength, int maxLength, Length expectedGeneratedLength) {
        validateGlobalLengthConstraints(minLength, maxLength);
        validateExpectedLengthConstraints(minLength, maxLength, expectedGeneratedLength.getMin(), expectedGeneratedLength.getMax());
    }

    /**
     * Validates that the specified lengths are within the global length constraints.
     *
     * @param minLength the minimum length to validate
     * @param maxLength the maximum length to validate
     * @throws RegexStringGeneratorException if the specified lengths are out of the global allowed range
     */
    private void validateGlobalLengthConstraints(int minLength, int maxLength) {
        ensureLengthConstraints(minLength, maxLength, this.globalMinLength, this.globalMaxLength);
    }

    /**
     * Validates that the specified lengths are within the expected length constraints.
     *
     * @param minLength         the minimum length to validate
     * @param maxLength         the maximum length to validate
     * @param expectedMinLength the expected minimum length from the automaton
     * @param expectedMaxLength the expected maximum length from the automaton
     * @throws RegexStringGeneratorException if the specified lengths are out of the expected range
     */
    private void validateExpectedLengthConstraints(int minLength, int maxLength, int expectedMinLength, int expectedMaxLength) {
        ensureLengthConstraints(minLength, maxLength, expectedMinLength, expectedMaxLength);
    }

    /**
     * Ensures that the specified lengths are within the allowed minimum and maximum lengths.
     *
     * @param minLength        the minimum length to check
     * @param maxLength        the maximum length to check
     * @param allowedMinLength the allowed minimum length
     * @param allowedMaxLength the allowed maximum length
     * @throws RegexStringGeneratorException if the lengths are not within the allowed range
     */
    private void ensureLengthConstraints(int minLength, int maxLength, int allowedMinLength, int allowedMaxLength) {
        StringBuilder errorMessage = new StringBuilder();
        if (minLength < allowedMinLength) {
            errorMessage.append("Specified minimum length ").append(minLength)
                    .append(" is less than the allowed minimum length ").append(allowedMinLength).append(". ");
        }
        if (maxLength > allowedMaxLength) {
            errorMessage.append("Specified maximum length ").append(maxLength)
                    .append(" exceeds the allowed maximum length ").append(allowedMaxLength).append(". ");
        }
        if (errorMessage.length() > 0) {
            throw new RegexStringGeneratorException(errorMessage.toString().trim());
        }
    }

    /**
     * Ensures that the automaton is initialized before any operations are performed on it.
     *
     * @throws RegexStringGeneratorException if the automaton has not been initialized
     */
    public void ensureAutomatonInitialized() {
        if (automaton == null) {
            throw new RegexStringGeneratorException("Automaton has not been initialized. Set RegExp first.");
        }
    }

    /**
     * Ensures that the automaton is finite.
     *
     * @throws RegexStringGeneratorException if the automaton is infinite
     */
    public void ensureAutomatonIsFinite() {
        if (!automaton.isFinite()) {
            throw new RegexStringGeneratorException("Automaton is infinite.");
        }
    }

    public void setRegExp(String regExp) {
        this.automaton = new RegExp(regExp).toAutomaton();
    }

    public Automaton getAutomaton() {
        return automaton;
    }

    public int getGlobalMaxLength() {
        return globalMaxLength;
    }

    public void setGlobalMaxLength(int maxLength) {
        this.globalMaxLength = maxLength;
    }

    public int getGlobalMinLength() {
        return globalMinLength;
    }

    public void setGlobalMinLength(int minLength) {
        this.globalMinLength = minLength;
    }
}
